import React from "react";
import m from "@midasit-dev/moaui";
import { Skeleton } from '@mui/material';

import { Editor } from "@monaco-editor/react";

import GridLoader from "react-spinners/GridLoader";

import { motion } from "framer-motion";

import { enqueueSnackbar } from "notistack";

// import Moment from "react-moment";
import moment from 'moment';

const App = () => {
  const inputRef = React.useRef<HTMLInputElement>(null);

	const [fileName, setFileName] = React.useState<string | null>("");
	const [fileSize, setFileSize] = React.useState<number | null>(0);
  const [content, setContent] = React.useState<string | null>(null);

	const [disabledImport, setDisabledImport] = React.useState(false);
	const [sendLoading, setSendLoading] = React.useState(false);

	const handleImport = React.useCallback(async () => {
		setTimeout(async () => {
			try {
				if (!inputRef.current) return;
				
				const startTime = new Date();

				inputRef.current.click();
				inputRef.current.onchange = (e) => {
					const file = (e.target as HTMLInputElement).files?.[0];
					if (!file) return;

					setFileName(file.name);
					setFileSize(file.size);

					const reader = new FileReader();
					reader.onload = (e) => {
						const content = e.target?.result;
						if (content === null) return;
		
						// const spacegassRegex =
						// 	/^SPACE GASS Text File - Version 1265\s*# Generated by SPACE GASS 14\.20 \(www\.spacegass\.com\)\s*# 1\. Blank lines are permitted anywhere in the file\s*# 2\. Comment lines must begin with the # character\s*# 3\. Continued lines must end with the & character\s*# 4\. Items within a line must be separated by commas\s*# 5\. Items that contain commas must be enclosed in quotes\s*# 6\. The maximum line length is 1024 characters\s*# 7\. The maximum total length of a set of continued lines is 4096 characters\s*# 8\. You can use \|\| as a carriage return in a block of text\s*\s*[\s\S]*\s*END\s*$/g;
						// const spacegassRegex = /(?s)^Version.*?END$/g;
						// if (!spacegassRegex.test(content as string)) {
						// 	enqueueSnackbar(`The file is not a valid spacegass file.`, {
						// 		variant: "error",
						// 	});
						// 	setContent(null);
						// 	return;
						// }

						const elapsedTime = Date.now() - startTime.getTime();
						const duration = moment.duration(elapsedTime);
						const formattedDuration = moment.utc(duration.asMilliseconds()).format("s[s]");

						enqueueSnackbar(
							`Successfully imported the spacegass file. (imported after ${formattedDuration})`,
							{ variant: "success" }
						);
						setContent(content as string);
					};
					reader.readAsText(file);
		
					// Reset the file input value to allow selecting the same file again
					if (e.target instanceof HTMLInputElement) {
						e.target.value = ""; // 파일 이름 초기화
					}
				};
			} catch (error) {
				console.error(error);
				setContent(null);
			} finally {}
		}, 500);
	}, [ setContent ]);

	const handleSend = React.useCallback(async () => {
		setTimeout(async () => {
			const startTime = new Date();
			
			try {
				if (!content) {
					enqueueSnackbar("No content to send", { variant: "error" });
					return;
				}

				setDisabledImport(true);

				const formData = new FormData();
				formData.append(
					"file",
					new Blob([content], { type: "text/plain" }),
					"data.txt"
				);
				const res = await fetch(
					process.env.REACT_APP_CONV_URL as string,
					{
						method: "POST",
						body: formData,
					}
				);
	
				if (!res.ok) {
					let errMsg = '';
					const data = await res.json();

					if (errMsg === '' && data.error && data.error.message) errMsg = data.error.message;
					if (errMsg === '' && res.status === 504) {
						errMsg = `The server took too long to convert the spacegass file to mct.`;
					}

					const elapsedTime = Date.now() - startTime.getTime();
					const duration = moment.duration(elapsedTime);
					const formattedDuration = moment.utc(duration.asMilliseconds()).format("s");

					errMsg = errMsg ? errMsg : `Failed to convert the spacegass file to mct.`;
					errMsg = `${errMsg} (it took ${formattedDuration})`;
					enqueueSnackbar(errMsg, { variant: "error" });
					return;
				}
	
				let mct = await res.text();
				mct = mct.replace(/\\/g, "\\\\");
				
				//도메인이 localhost 이거나 midasit-dev.github.io 일때만 사용
				if (
					window.location.hostname === "localhost" || 
					window.location.hostname === "midasit-dev.github.io"
				) {
					// console.log(mct);
				}
				mct = mct.replace(
					";---------------------------------------------------------------------------\n;  midas Civil Text(MCT) File.\n;  Date : \n;---------------------------------------------------------------------------\n \n",
					""
				);
	
				// enqueueSnackbar(`Successfully converted the spacegass file to mct.`, { variant: "success", });

				const url = await m.VerifyUtil.getBaseUrlAsync();
				const mapiKey = m.VerifyUtil.getMapiKey();
				const resMxtCmdShell = await fetch(`${url}/ope/mxtcmdshell`, {
					headers: {
						"Content-Type": "application/json",
						"MAPI-Key": mapiKey,
					},
					method: "POST",
					body: JSON.stringify({
						Argument: mct,
					}),
				});

				const elapsedTime = Date.now() - startTime.getTime();
				const duration = moment.duration(elapsedTime);
				const formattedDuration = moment.utc(duration.asMilliseconds()).format("s[s]");
	
				if (!resMxtCmdShell.ok) {
					let errMsg = '';
					const data = await resMxtCmdShell.json();
					if (errMsg === '' && data.error && data.error.message) errMsg = data.error.message;
					if (errMsg === '' && resMxtCmdShell.status === 504) {
						errMsg = `The server took too long to send the mct.`;
					}

					errMsg = errMsg ? errMsg : `Failed to convert the spacegass file to mct.`;
					errMsg = `${errMsg} (it took ${formattedDuration})`;
					enqueueSnackbar(errMsg, { variant: "error" });
					return;
				}
	
				enqueueSnackbar(`Successfully sent the mct. (it took ${formattedDuration})`, {
					variant: "success",
				});

				return;
			} catch (error) {
				enqueueSnackbar(`There is unknown server error... (timeout is 60s)`, { variant: "error" });
			} finally {
				setSendLoading(false);
				setDisabledImport(false);
			}
		}, 1000);
	}, [ content, setSendLoading ]);

	const [sendDuringText, setSendDuringText] = React.useState<string | null>('0s');

	React.useEffect(() => {
		if (!sendLoading) return;
		const sendStartTime = new Date();
		const interval = setInterval(() => {
			if (!sendStartTime) return;
			const elapsedTime = Date.now() - sendStartTime.getTime();
			const duration = moment.duration(elapsedTime);
			const formattedDuration = moment.utc(duration.asMilliseconds()).format("s[s]");
			setSendDuringText(formattedDuration);
		}, 1000);

		handleSend();

		return () => {
			if (interval) {
				clearInterval(interval);
			}
			setSendDuringText('0s');
		}
	}, [sendLoading, handleSend]);

	React.useEffect(() => {
		setDisabledImport(sendLoading);
	}, [sendLoading]);

  return (
    <m.GuideBox width={800} spacing={2} padding={2}>
      <m.VerifyDialog />
      <m.GuideBox row width="100%" horSpaceBetween verCenter>
        <m.Typography>
          Please insert the text file extracted from Spacegass
        </m.Typography>
        <m.GuideBox row verCenter spacing={2}>
          <input
            ref={inputRef}
            type="file"
            style={{ display: "none" }}
            accept=".txt"
          />

          {fileName && fileSize ? (
            <m.Chip
              severity="success"
              size="small"
              label={`${(fileSize * 0.000001).toFixed(2)} mb`}
            ></m.Chip>
          ) : (
            <Skeleton variant="text" width={100} />
          )}

          <m.Button onClick={() => handleImport()} disabled={disabledImport}>
            Import
          </m.Button>
          <m.Button
            onClick={() => setSendLoading(true)}
            color="negative"
            disabled={!content}
          >
            {sendLoading ? `Sending ... (${sendDuringText})` : `Send`}
          </m.Button>
        </m.GuideBox>
      </m.GuideBox>
      <TextEditorWithReadOnly content={content} />
    </m.GuideBox>
  );
};

export default App;

const TextEditorWithReadOnly = (props: any) => {
  const { content } = props;

  const editorRef = React.useRef(null);

  function handleEditorDidMount(editor: any, monaco: any) {
    editorRef.current = editor;
  }

  return (
    <m.Panel width="100%" title="Imported Text">
      <motion.div
        initial={{
          opacity: 0,
        }}
        animate={{
          opacity: 1,
          transition: {
            duration: 0.5,
          },
        }}
        style={{
          width: "100%",
          height: 300,
					display: 'flex',
					justifyContent: 'center',
					alignItems: 'center',
        }}
      >
        {content === null && (
					<m.GuideBox opacity={0.5} spacing={2}>
						<m.Typography>Waiting ...</m.Typography>
						<GridLoader size={10} />
					</m.GuideBox>
				)}
        {content !== null && (
					<Editor
						height={300}
						defaultLanguage="text"
						defaultValue=""
						value={content ?? ""}
						onMount={handleEditorDidMount}
						// onChange={debounceEditorChange}
						loading={
							<m.GuideBox opacity={0.5} spacing={2}>
								<m.Typography>Importing ...</m.Typography>
								<GridLoader size={10} />
							</m.GuideBox>
						}
						options={{
							readOnly: true,
						}}
					/>
        )}
      </motion.div>
    </m.Panel>
  );
};
